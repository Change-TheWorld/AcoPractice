<!-- 阮一峰JS教程阅读札记之JS运算符篇 -->

# 运算符

运算符是处理数据的基本方法，用来从现有数据得到新的数据。

## 加法运算符

可以完成两种运算，既可以处理算术的加法，也可以用作字符串连接。

1. 如果运算子是对象，先自动转成原始类型的值（即先执行该对象的valueOf方法，如果结果还不是原始类型的值，再执行toString方法；如果对象是Date实例，则先执行toString方法）。
2. 两个运算子都是原始类型的值以后，只要有一个运算子是字符串，则两个运算子都转为字符串，执行字符串连接运算。
3. 否则，两个运算子都转为数值，执行加法运算。

```js
// 加法
1 + 1 // 2
true + true // 2
1 + true // 2

// 字符串连接
'1' + '1' // "11"
'1.1' + '1.1' // "1.11.1"

'1' + {foo: 'bar'} // "1[object Object]"
'1' + 1 // "11"
'1' + true // "1true"
'1' + [1] // "11"
```

这种由于参数不同，而改变自身行为的现象，叫做“重载”（overload）。由于加法运算符是运行时决定到底执行那种运算，使用的时候必须很小心。

```js
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"

var now = new Date();
typeof (now + 1) // "string"
typeof (now - 1) // "number"

// 一个值加上空字符串，会使得该值转为字符串形式。
x + '' // 'x'

// 加法运算符会将其他类型的值，自动转为字符串，然后再执行连接运算。
[1, 2] + [3]
// "1,23"

// 等同于
String([1, 2]) + String([3])
// '1,2' + '3'
```

加法运算符一定有左右两个运算子，如果只有右边一个运算子，就是另一个运算符，叫做“数值运算符”。

```js
+ - 3 // 等同于 +(-3)
+ 1 + 2 // 等同于 +(1 + 2)
+ '1' // 1

1 +
// SyntaxError: Unexpected end of input
```

加法运算符以外的其他算术运算符（比如减法、除法和乘法），都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。

```js
1 - '2' // -1
1 * '2' // 2
1 / '2' // 0.5
```

## 算数运算符

    加法运算符（Addition）：x + y
    减法运算符（Subtraction）： x - y
    乘法运算符（Multiplication）： x * y
    除法运算符（Division）：x / y
    余数运算符（Remainder）：x % y
    自增运算符（Increment）：++x 或者 x++
    自减运算符（Decrement）：--x 或者 x--
    数值运算符（Convert to number）： +x
    负数值运算符（Negate）：-x

### 余数运算符

余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数。

```js
12 % 5 // 2

// 需要注意的是，运算结果的正负号由第一个运算子的正负号决定。
-1 % 2 // -1
1 % -2 // 1

// 正确的写法：为了得到正确的负数的余数值，需要先使用绝对值函数。
function isOdd(n) {
  return Math.abs(n % 2) === 1;
}
isOdd(-5) // true
isOdd(-4) // false
```

### 自增和自减运算符

自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。

```js
var x = 1;
++x // 2
x // 2

--x // 1
x // 1

// 注意：放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。

var x = 1;
var y = 1;

x++ // 1
x // 2
++y // 2
y // 2
```

### 数值运算符，负数值运算符

数值运算符（+）同样使用加号，但是加法运算符是二元运算符（需要两个操作数），它是一元运算符（只需要一个操作数）。

数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。

```js
+true // 1
+[] // 0
+{} // NaN

// 负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。

// 数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。

var x = 1;
-x // -1
x // 1
-(-x) // 1
```

### 赋值运算符

用于给变量赋值。

除此之外，JavaScript还提供其他11个复合的赋值运算符。

```js
x += y // 等同于 x = x + y
x -= y // 等同于 x = x - y
x *= y // 等同于 x = x * y
x /= y // 等同于 x = x / y
x %= y // 等同于 x = x % y
x >>= y // 等同于 x = x >> y
x <<= y // 等同于 x = x << y
x >>>= y // 等同于 x = x >>> y
x &= y // 等同于 x = x & y
x |= y // 等同于 x = x | y
x ^= y // 等同于 x = x ^ y
```

这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量。

### 比较运算符

比较运算符用于比较两个值，然后返回一个布尔值，表示是否满足比较条件。一共提供了8个比较运算符.

    == 相等
    === 严格相等
    != 不相等
    !== 严格不相等
    < 小于
    <= 小于或等于
    > 大于
    >= 大于或等于

比较运算符可以比较各种类型的值，不仅仅是数值。除了相等运算符号和精确相等运算符，其他比较运算符的算法如下。

> 如果两个运算子都是字符串，则按照字典顺序比较（实际上是比较Unicode码点）。
> 否则，将两个运算子都转成数值，再进行比较（等同于先调用Number函数）。

```js
5 > '4' // true
// 等同于 5 > Number('4')
// 即 5 > 4

true > false // true
// 等同于 Number(true) > Number(false)
// 即 1 > 0

2 > true // true
// 等同于 2 > Number(true)
// 即 2 > 1

// 如果运算子是对象，必须先将其转为原始类型的值，即先调用valueOf方法，如果返回的还是对象，再接着调用toString方法。
var x = [2];
x > '11' // true
// 等同于 [2].valueOf().toString() > '11'
// 即 '2' > '11'

x.valueOf = function () { return '1' };
x > '11' // false
// 等同于 [2].valueOf() > '11'
// 即 '1' > '11'

// 两个对象之间的比较也是如此。
[2] > [1] // true
// 等同于 [2].valueOf().toString() > [2].valueOf().toString()
// 即 '2' > '1'

{x: 2} >= {x: 1} // true
// 等同于 {x: 2}.valueOf().toString() >= {x: 1}.valueOf().toString()
// 即 '[object Object]' >= '[object Object]'
```

#### 字符串的比较

字符串按照字典顺序进行比较。首先比较首字符的Unicode码点，如果相等，再比较第二个字符的Unicode码点，以此类推。

```js
'cat' > 'dog' // false
'cat' > 'catalog' // false

'cat' > 'Cat' // true', 小写的c的Unicode码点（99）大于大写的C的Unicode码点（67），所以返回true。

// 由于所有字符都有Unicode码点，因此汉字也可以比较。
'大' > '小' // false
// “大”的Unicode码点是22823，“小”是23567，因此返回false。
```

#### 严格相等运算符

它们的区别是相等运算符（`==`）比较两个值是否相等，严格相等运算符（`===`）比较它们是否为“同一个值”。

如果两个值不是同一类型，严格相等运算符（`===`）直接返回false，而相等运算符（`==`）会将它们转化成同一个类型，再用严格相等运算符进行比较。

```js
// 不同类型的值
1 === "1" // false
true === "true" // false

// 同一类的原始类型值,同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。

1 === 0x1 // true, 比较十进制的1与十六进制的1，因为类型（数值类型）和值都相同
NaN === NaN  // false
+0 === -0 // true
undefined === undefined // true
null === null // true

// 两个只声明未赋值的变量是相等的。
var v1;
var v2;
v1 === v2 // true

// 同一类的复合类型值， 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象，是否引用同一个内存地址。

// 空对象、空数组、空函数的值，都存放在不同的内存地址
{} === {} // false
[] === [] // false
(function (){} === function (){}) // false

// 如果两个变量引用同一个对象，则它们相等。
var v1 = {};
var v2 = v1;
v1 === v2 // true
```

注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。

```js
new Date() > new Date() // false
new Date() < new Date() // false
new Date() === new Date() // false

// 严格相等运算符有一个对应的“严格不相等运算符”（!==），两者的运算结果正好相反。

1 !== '1' // true

```

#### 相等运算符

相等运算符比较相同类型的数据时，与严格相等运算符完全一样。

比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下。

```js
// 原始类型的数据会转换成数值类型再进行比较。
1 == true // true
// 等同于 1 === 1

0 == false // true
// 等同于 0 === 0

2 == true // false
// 等同于 2 === 1

'true' == true // false
// 等同于 Number('true') === Number(true)
// 等同于 NaN === 1

'' == 0 // true
// 等同于 Number('') === 0
// 等同于 0 === 0

'' == false  // true
// 等同于 Number('') === Number(false)
// 等同于 0 === 0

'\n  123  \t' == 123 // true
// 因为字符串转为数字时，省略前置和后置的空格

// 对象与原始类型值比较, 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。

[1] == 1 // true
// 等同于 Number([1]) == 1

[1] == '1' // true
// 等同于 String([1]) == Number('1')

[1] == true // true
// 等同于 Number([1]) == Number(true)

// undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。
false == null // false
false == undefined // false

0 == null // false
0 == undefined // false

undefined == null // true

// 绝大多数情况下，对象与undefined与null比较，都返回false。只有在对象转为原始值得到undefined时，才会返回true，
```

相等运算符隐藏的类型转换，会带来一些违反直觉的结果。下面这些表达式都很容易出错，因此不要使用相等运算符（==），最好只使用严格相等运算符（===）。

```js
'' == '0'           // false
0 == ''             // true
0 == '0'            // true

2 == true           // false
2 == false          // false

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
```

相等运算符有一个对应的“不相等运算符”（!=），两者的运算结果正好相反。

### 布尔运算符

用于将表达式转为布尔值

    取反运算符：!
    且运算符：&&
    或运算符：||
    三元运算符：?:

#### 取反运算符（!）

```js
!true // false
!false // true

// 对于非布尔值的数据，取反运算符会自动将其转为布尔值。规则是，以下六个值取反后为true，其他值取反后都为false。
/*
undefined
null
false
0（包括+0和-0）
NaN
空字符串（''）
*/

// 这意味着，取反运算符有转换数据类型的作用。(且运算符、或运算符、三元条件运算符）也是如此

!undefined // true
!null // true
!0 // true
!NaN // true
!"" // true

!54 // false
!'hello' // false
![] // false
!{} // false

!!x
// 等同于
Boolean(x)
```

#### 且运算符

如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。

```js
't' && '' // ""
't' && 'f' // "f"
't' && (1 + 2) // 3
'' && 'f' // ""
'' && '' // ""

var x = 1;
(1 - 1) && ( x += 1) // 0
x // 1

// 这种跳过第二个运算子的机制，被称为“短路”。有些时候可以用来取代if结构（不容易看出目的，也不容易除错，建议谨慎使用。）不利于 语义化
if (i) {
  doSomething();
}
// 等价于
i && doSomething();

// 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。

true && 'foo' && '' && 4 && 'foo' && true
// ''
```

#### 或运算符（||）

如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。

```js
// 短路规则对这个运算符也适用。
// 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。
false || 0 || '' || 4 || 'foo' || true
// 4

// 或运算符常用于为一个变量设置默认值。
function saveText(text) {
  text = text || '';
  // ...
}

// 或者写成
saveText(this.text || '')
```

#### 三元条件运算符（?:）

三元条件运算符用问号（?）和冒号（:），分隔三个表达式。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。

三元条件表达式与if...else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else。

```js
't' ? 'hello' : 'world' // "hello"
0 ? 'hello' : 'world' // "world"
```

### 位运算符

位运算符用于直接对二进制位进行计算，一共有7个。

  `或运算（or）：符号为|`，表示若两个二进制位都为0，则结果为0，否则为1。
  `与运算（and）：符号为&`，表示若两个二进制位都为1，则结果为1，否则为0。
  `否运算（not）：符号为~`，表示对一个二进制位取反。
  `异或运算（xor）：符号为^`，表示若两个二进制位不相同，则结果为1，否则为0。
  `左移运算（left shift）：符号为<<`，详见下文解释。
  `右移运算（right shift）：符号为>>`，详见下文解释。
  `带符号位的右移运算（zero filled right shift）：符号为>>>`，详见下文解释。

这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，

有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在JavaScript内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。

```js
// 将i（不管是整数或小数）转为32位整数。
i = i | 0;

// 利用这个特性，可以写出一个函数，将任意数值转为32位整数。
function toInt32(x) {
  return x | 0;
}

toInt32(1.001) // 1
toInt32(1.999) // 1
toInt32(1) // 1
toInt32(-1) // -1
toInt32(Math.pow(2, 32) + 1) // 1, 因为一个整数大于32位的数位都会被舍去。
toInt32(Math.pow(2, 32) - 1) // -1
```

#### “或运算”与“与运算”

逐位比较两个运算子。“或运算”的规则是，两个二进制位之中只要有一个为1，就返回1，否则返回0。“与运算”的规则是，两个二进制位之中只要有一个位为0，就返回0，否则返回1。

```js
0 | 3 // 3, (00和11, 得到11)
0 & 3 // 0，(00和11, 得到00)

// 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分
2.9 | 0 // 2
-2.9 | 0 // -2

// 需要注意的是，这种取整方法不适用超过32位整数最大值2147483647的数。

2147483649.4 | 0;
// -2147483647
```

#### 否运算

“否运算”将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。

一个数与自身的取反值相加，等于-1。`即值x 的取反值 = -1 - x`.

```js
~ 3 // -4, 可以简单理解为 -1 - 3 = -4
~ -3 // 2, -1减去-3，结果为2

// 一个整数连续两次“否运算”，得到它自身。
~~3 // 3

// 所有的位运算都只对整数有效。否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次否运算，能达到取整效果。

// 使用否运算取整，是所有取整方法中最快的一种。
~~2.9 // 2
~~47.11 // 47
~~1.9999 // 1
~~3 // 3

// 对字符串进行否运算，JavaScript引擎会先调用Number函数，将字符串转为数值。

// 以下例子相当于~Number('011')
~'011'  // -12
~'42 cats' // -1
~'0xcafebabe' // 889275713
~'deadbeef' // -1

// 以下例子相当于~~Number('011')
~~'011';        // 11
~~'42 cats';    // 0
~~'0xcafebabe'; // -889275714
~~'deadbeef';   // 0

~~[] // 0
~~NaN // 0
~~null // 0
```

#### 异或运算

“异或运算”在两个二进制位不同时返回1，相同时返回0。

```js
0 ^ 3 // 3

// “异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，aˆ=b, bˆ=a, aˆ=b，可以互换它们的值

// 互换两个变量的值的最快方法。
var a = 10;
var b = 99;

a ^= b, b ^= a, a ^= b;
a // 99
b // 10

// 异或运算也可以用来取整。
12.9 ^ 0 // 12
```

#### 左移(<<)和右移(>>)运算符

左移运算符表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方（最高位即符号位不参与移动）。

```js
// 4 的二进制形式为100，
// 左移一位为1000（即十进制的8）
// 相当于乘以2的1次方
4 << 1
// 8

-4 << 1
// -8

// 如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。
13.5 << 0
// 13

-13.5 << 0
// -13

// 左移运算符用于二进制数值非常方便。
var color = {r: 186, g: 218, b: 85};

// RGB to HEX
// (1 << 24)的作用为保证结果是6位数
var rgb2hex = function(r, g, b) {
  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b)
    .toString(16)
    .substr(1);
}

rgb2hex(color.r,color.g,color.b)
// "#bada55"
```

右移运算符表示将一个数的二进制值向右移动指定的位数，头部补0，即除以2的指定次方（最高位即符号位不参与移动）.

```js
4 >> 1
// 2
/*
// 因为4的二进制形式为00000000000000000000000000000100，
// 右移一位得到00000000000000000000000000000010，
// 即为十进制的2
*/

-4 >> 1
// -2
/*
// 因为-4的二进制形式为11111111111111111111111111111100，
// 右移一位，头部补1，得到11111111111111111111111111111110,
// 即为十进制的-2
*/

// 右移运算可以模拟2的整除运算。
5 >> 1
// 相当于 5 / 2 = 2

21 >> 2
// 相当于 21 / 4 = 5
```

带符号位的右移运算符(>>>), 该运算符表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0。所以，该运算总是得到正值。

对于正数，该运算的结果与右移运算符（»）完全一致，区别主要在于负数。

```js
4 >>> 1
// 2

-4 >>> 1
// 2147483646
/*
// 因为-4的二进制形式为11111111111111111111111111111100，
// 带符号位的右移一位，得到01111111111111111111111111111110，
// 即为十进制的2147483646。
*/

// 这个运算实际上将一个值转为32位无符号整数。查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。

-1 >>> 0 // 4294967295

// 开关作用 ???

/*
假定某个对象有四个开关，每个开关都是一个变量, 设置一个四位的二进制数，它的每个位对应一个开关。
*/
var FLAG_A = 1; // 0001
var FLAG_B = 2; // 0010
var FLAG_C = 4; // 0100
var FLAG_D = 8; // 1000

var flags = 5; // 二进制的0101

// 就可以用“与运算”检验，当前设置是否打开了指定开关。检验是否打开了开关C
if (flags & FLAG_C) {
  // ...
}
// 0101 & 0100 => 0100 => true

// 现在假设需要打开ABD三个开关，我们可以构造一个掩码变量。

var mask = FLAG_A | FLAG_B | FLAG_D;
// 0001 | 0010 | 1000 => 1011

// 有了掩码，“或运算”可以确保打开指定的开关。
flags = flags | mask;

// “与运算”可以将当前设置中凡是与开关设置不一样的项，全部关闭。
flags = flags & mask;

// “异或运算”可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。
flags = flags ^ mask;

// “否运算”可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0。
flags = ~flags;
```

#### 其他运算符

#### void运算符

void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。

```js
void 0 // undefined
void(0) // undefined ,推荐，建议采用这一种形式，即总是使用括号。因为void运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，void 4 + 7实际上等同于(void 4) + 7。

// 这个运算符主要是用于书签工具（bookmarklet），以及用于在超级链接中插入代码，目的是返回undefined可以防止网页跳转。

<a href="javascript:void window.open('http://example.com/')">
  点击打开新窗口
</a>

// 上面代码用于在网页中创建一个链接，点击后会打开一个新窗口。如果没有void，点击后就会在当前窗口打开链接。

<a href="javascript: void(f())">文字</a>
<a href="javascript: void(document.form.submit())">
文字</a>
```

#### 逗号运算符

逗号运算符用于对两个表达式求值，并返回后一个表达式的值。

```js
'a', 'b' // "b"

var x = 0;
var y = (x++, 10);
x // 1
y // 10
```

## 运算顺序

### 优先级

从高到低依次为： 小于等于（<=)、严格相等（===）、或（||）、三元（?:）、等号（=）。

圆括号（()）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。

建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。

圆括号不是运算符，而是一种语法结构。它一共有两种用法：`一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。`

```js
var x = 1;
(x) = 2; // 2, 等同于 x = 2


(exprssion)
// 等同于
expression

// 函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。

function f() {
  return 1;
}
(f) // function f(){return 1;}
f() // 1

// 圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。
(var a = 1)
// SyntaxError: Unexpected token var
```

### 左结合与右结合

对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的“左结合”（left-to-right associativity），即从左边开始计算。

如 `x + y + z`.

但是少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的“右结合”（right-to-left associativity）。其中，最主要的是赋值运算符（=）和三元条件运算符（?:）。

```js
w = x = y = z;
q = a ? b : c ? d : e ? f : g;

// 等同于
w = (x = (y = z));
q = a ? b : (c ? d : (e ? f : g));

```